# TASK 07 — Create Domain Entities

## Goal

Persist a domain’s data model in a relational SQL database and expose repository-backed CRUD in the API.

## Scope

- Framework: NestJS (TypeScript). 
- ORM: TypeORM .
- SQL engines: any supported RDBMS (e.g., PostgreSQL, MySQL/MariaDB, Oracle, SQL Server). 

The task must not assume a specific vendor and should rely on ORM-provided abstractions and vendor-agnostic migrations where possible.

## Acceptance Criteria

* Entities mirror the domain JSON spec (names, types, nullability, PK/FK, uniques, indexes) using ORM decorators/metadata, without vendor-specific SQL in code.
* Schema creation is performed via migrations generated by the ORM or toolchain; application startup uses schema synchronization disabled (e.g., synchronize: false).
* Service layer uses repositories/clients to persist and query real data (no in-memory stubs).
* Local, test, and CI flows provision an RDBMS service for the chosen engine, apply migrations, then execute tests successfully.
* Documentation explains engine selection, configuration via environment variables, migration workflow, and test execution for at least one engine; it also calls out any engine-specific notes (e.g., UUID default generation, timestamp types, partial/filtered indexes) with alternatives where another engine is used.

## Inputs

* project.domain.Persisted Data schema
* Connection settings via environment variables (host, port, user, password, database, optional schema/catalog, SSL/TSL flags) suitable for the selected engine.


## Outputs

* entities under project-root/api/src/{{domain}}/entities
* ORM configuration and migrations under project-root/api/src/{{domain}}/database
* Repository-backed service(s) under project-root/api/src/{{domain}}/services
* Updated scripts and docs

## Constraints and Guidance

* Use ORM-level column types mapped from the JSON spec; when engine capabilities differ (e.g., UUID, filtered indexes), prefer ORM abstractions or provide conditional migration strategies per engine.
* Avoid embedding engine-specific SQL in application code; if unavoidable for certain features, confine it to migration files with guarded paths or engine checks.
* For CI, parameterize the engine choice and credentials; provide at least one working CI example with a popular engine and document how to switch to others.

## Assumptions

- JSON Schema uses definitions where each definition represents a table-like object.
- x-db extensions carry relational metadata:

    - primaryKey: string\[] (columns)
    - foreignKey: { column: string, ref: "OtherDef.column" }\[]
    - unique: string\[]\[] (composite allowed)
    - indexes: (string\[] | { columns: string\[], predicate?: string })\[]
- Required array indicates NOT NULL columns (except where a business rule requires nullable).
- Date-time fields map to timestamptz-ish types via TypeORM abstractions; exact SQL type resolved by driver.

## Mapping Rules

- Name resolution

    - ClassName = PascalCase(defName), table name = pluralized snake\_case of defName by default. If you don’t want pluralization, disable in config.
    - Column names remain as-is from schema (typically snake\_case).
    - @Entity({ name, schema?: dbSchema })
- Scalar types

    - string (format: uuid) → 'uuid'
    - string (format: date-time) → @CreateDateColumn/@UpdateDateColumn if named created\_at/updated\_at; otherwise Column('timestamptz' | 'timestamp')
    - string with maxLength → Column('varchar', { length })
    - string fixed 2-char country → Column('char', { length: 2 })
    - integer → Column('integer')
    - boolean → Column('boolean')
- Nullability

    - required includes column → nullable: false
    - else → nullable: true
- Primary keys

    - If PK single integer → @PrimaryGeneratedColumn({ type: 'integer' })
    - If PK uuid:

        * idStrategy.uuidDefault = 'db' → @Column('uuid', { primary: true, default: () => engine==='postgres'?'gen\_random\_uuid()':'uuid\_generate\_v4()' /\* or omit \*/ })
        * idStrategy.uuidDefault = 'orm' (default) → @PrimaryGeneratedColumn('uuid')
    * Composite PKs → @PrimaryColumn for each component (no @PrimaryGeneratedColumn)
* Foreign keys

    * For each { column, ref: "OtherDef.column" }:

        * Add @Column for FK column
        * Add @ManyToOne(() => OtherDefClass, { onDelete: 'SET NULL' | 'CASCADE' (not inferred unless specified elsewhere) })
        * @JoinColumn({ name: column, referencedColumnName: '...' })
* Uniques

    * @Unique('ux\_<table>\_\<cols\_joined>', \['colA', 'colB'])
* Indexes

    * @Index('ix\_<table>\_<col>', \['col'])
    * Partial/filtered index: if predicate available and engine === 'postgres', use @Index(..., { where: '<predicate>' }); else skip or emit migration-only note.
* Relations (reverse)

    * If A has FK to B, generator may optionally emit @OneToMany on B referencing A; enable with flag addInverseRelations (default true)
* Timestamps

    * created\_at → @CreateDateColumn({ type: 'timestamptz' })
    * updated\_at → @UpdateDateColumn({ type: 'timestamptz' })
* Validation (optional)

    * If generateDto: true, emit DTOs with class-validator from the same JSON rules (not part of this tool’s core output unless requested)

## Directory Structure (authoritative)

* project-root/api/src/{{domain}}/entities
* project-root/api/src/{{domain}}/services
* project-root/api/src/{{domain}}/database


