# TASK — Create Domain Entities

Goal
Persist a domain’s data model in a relational SQL database and expose repository-backed CRUD in the API.

Scope
Framework: NestJS (TypeScript). ORM: TypeORM (or Prisma/Sequelize). SQL engines: any supported RDBMS (e.g., PostgreSQL, MySQL/MariaDB, Oracle, SQL Server). The task must not assume a specific vendor and should rely on ORM-provided abstractions and vendor-agnostic migrations where possible.

Acceptance Criteria

* Entities mirror the domain JSON spec (names, types, nullability, PK/FK, uniques, indexes) using ORM decorators/metadata, without vendor-specific SQL in code.
* Schema creation is performed via migrations generated by the ORM or toolchain; application startup uses schema synchronization disabled (e.g., synchronize: false).
* Service layer uses repositories/clients to persist and query real data (no in-memory stubs).
* Local, test, and CI flows provision an RDBMS service for the chosen engine, apply migrations, then execute tests successfully.
* Documentation explains engine selection, configuration via environment variables, migration workflow, and test execution for at least one engine; it also calls out any engine-specific notes (e.g., UUID default generation, timestamp types, partial/filtered indexes) with alternatives where another engine is used.

Inputs

* project.domain.Persisted Data schema
* Connection settings via environment variables (host, port, user, password, database, optional schema/catalog, SSL/TSL flags) suitable for the selected engine.


Outputs

* entities under project-root/api/src/{{domain}}/entities
* ORM configuration and migrations under project-root/api/src/{{domain}}/database
* Repository-backed service(s) under project-root/api/src/{{domain}}/services
* Updated scripts and docs

Constraints and Guidance

* Use ORM-level column types mapped from the JSON spec; when engine capabilities differ (e.g., UUID, filtered indexes), prefer ORM abstractions or provide conditional migration strategies per engine.
* Avoid embedding engine-specific SQL in application code; if unavoidable for certain features, confine it to migration files with guarded paths or engine checks.
* For CI, parameterize the engine choice and credentials; provide at least one working CI example with a popular engine and document how to switch to others.

Directory Structure (authoritative)

* project-root/api/src/{{domain}}/entities
* project-root/api/src/{{domain}}/services
* project-root/api/src/{{domain}}/database


**Tools**

api/TOOL - JSON Entity Spec to Entities.tool.md

